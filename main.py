#!/usr/bin/env python3
import functions_framework
from google import genai
from google.genai import types
from google.cloud import storage
from google.cloud import bigquery
import pypdf
import io
import json
import datetime
import decimal
# --- Configuration ---
PROJECT_ID = "obedio"
LOCATION = "us-central1"
BUCKET_NAME = "obedio.appspot.com"
# Limits
MAX_FILE_SIZE_MB = 300
TRUNCATE_LIMIT = 50
FALLBACK_PAGES = 25
# --- Initialize Services (Global Scope for Warm Start) ---
_genai_client = None
_storage_client = None
_bq_client = None
def get_genai_client():
    global _genai_client
    if _genai_client is None:
        _genai_client = genai.Client(
            vertexai=True, project=PROJECT_ID, location=LOCATION
        )
    return _genai_client
def get_storage_client():
    global _storage_client
    if _storage_client is None:
        _storage_client = storage.Client(project=PROJECT_ID)
    return _storage_client
def get_bq_client():
    global _bq_client
    if _bq_client is None:
        _bq_client = bigquery.Client(project=PROJECT_ID)
    return _bq_client
@functions_framework.http
def main_router(request):
    path = request.path.rstrip("/")
    if path == "":
        print("Health check request received", flush=True)
        return "OK", 200
    if path == "/g":
        return get_file(request)
    elif path == "/s":
        return summarize_pdf(request)
    elif path == "/q":
        return query_bigquery_charts(request)
    elif path == "/j":  # <--- Add this
        return query_bigquery_json(request)
    else:
        if request.method == "OPTIONS":
            return handle_cors_options()
        return "Invalid route. Use /g, /s, /q, or /j.", 404
# ---------------------------------------------------------
# ROUTE: /g (Get File)
# ---------------------------------------------------------
def get_file(request):
    """Reads a file from GCS/meetings and returns it raw."""
    filename = request.args.get("file")
    if not filename:
        return 'Error: Missing "file" param.', 400
    try:
        bucket = get_storage_client().bucket(BUCKET_NAME)
        blob = bucket.blob(f"meetings/{filename}")
        if not blob.exists():
            return "Error: File not found.", 404
        file_content = blob.download_as_bytes()
        content_type = blob.content_type or "application/octet-stream"
        return file_content, 200, {"Content-Type": content_type}
    except Exception as e:
        return f"Error retrieving file: {str(e)}", 500
# ---------------------------------------------------------
# ROUTE: /s (Summarize PDF)
# ---------------------------------------------------------
def summarize_pdf(request):
    """Summarizes PDF with Custom Obedio Styling."""
    filename = request.args.get("file")
    topic = request.args.get("topic")
    theme = request.args.get("theme")
    if not filename:
        return 'Error: Missing "file" param.', 400
    # Base instructions
    default_instr_parts = [
        "Summarize this in html and get related contact info and url links.",
        "Make it look nice with html formatting.",
        "The left and right margins should be about 1 inch wide on a standard letter page. ",
        'Put a header at the top with the title "Obedio AI-Generated Document Summary". ',
        "Add this at the very bottom in muted, small text: "
        '"Disclaimer: This document was generated by Obedio AI from the first 25 pages of the original source document. While we strive for accuracy, please verify critical details with the original source document. AI can be wildly inaccurate."',
        "Do not add any other text outside the HTML structure.",
    ]
    # Add topic/theme instruction if present
    if topic or theme:
        special_instruction = "Make sure to pick up on anything related to"
        if topic:
            special_instruction += f" the topic of '{topic}'"
        if topic and theme:
            special_instruction += " and"
        if theme:
            special_instruction += f" the theme of '{theme}'"
        special_instruction += "."
        default_instr_parts.insert(1, special_instruction)
    default_instr = " ".join(default_instr_parts)
    custom_instructions = request.args.get("instructions", default_instr)
    try:
        # 1. Check File Size (Metadata)
        bucket = get_storage_client().bucket(BUCKET_NAME)
        blob = bucket.blob(filename)
        if not blob.exists():
            return f"Error: File '{filename}' not found.", 404
        blob.reload()
        file_size_mb = blob.size / (1024 * 1024)
        if file_size_mb > MAX_FILE_SIZE_MB:
            return (
                f"Error: File is {file_size_mb:.2f}MB. Limit is {MAX_FILE_SIZE_MB}MB.",
                400,
            )
        # 2. Download
        pdf_bytes = blob.download_as_bytes()
        try:
            input_stream = io.BytesIO(pdf_bytes)
            pdf_reader = pypdf.PdfReader(input_stream)
            num_pages = len(pdf_reader.pages)
        except Exception as e:
            return f"Error reading PDF structure: {str(e)}", 400
        # 3. Prepare Content
        parts = []
        if num_pages > TRUNCATE_LIMIT or file_size_mb > 30:
            output_stream = io.BytesIO()
            pdf_writer = pypdf.PdfWriter()
            limit = min(FALLBACK_PAGES, num_pages)
            for i in range(limit):
                pdf_writer.add_page(pdf_reader.pages[i])
            pdf_writer.write(output_stream)
            truncated_bytes = output_stream.getvalue()
            parts.append(
                types.Part.from_bytes(data=truncated_bytes, mime_type="application/pdf")
            )
            custom_instructions += (
                f" [NOTE: File truncated. You are seeing the first {limit} pages.]"
            )
        else:
            file_uri = f"gs://{BUCKET_NAME}/{filename}"
            parts.append(
                types.Part.from_uri(file_uri=file_uri, mime_type="application/pdf")
            )
        parts.append(types.Part.from_text(text=custom_instructions))
        # 4. Generate Content
        response = get_genai_client().models.generate_content(
            model="gemini-2.0-flash", contents=[types.Content(role="user", parts=parts)]
        )
        # 5. Safety & Empty Check
        if not response.text:
            return (
                f"Error: AI returned empty text. Reason: {response.candidates[0].finish_reason}",
                500,
            )
        # 6. Clean Output
        cleaned_text = response.text.replace("```html", "").replace("```", "")
        if "<!DOCTYPE" in cleaned_text:
            cleaned_text = cleaned_text[cleaned_text.find("<!DOCTYPE") :]
        elif "<html" in cleaned_text:
            cleaned_text = cleaned_text[cleaned_text.find("<html") :]
        return cleaned_text, 200, {"Content-Type": "text/html"}
    except Exception as e:
        return f"Error processing file: {str(e)}", 500
# ---------------------------------------------------------
# ROUTE: /q (BigQuery Charts API)
# ---------------------------------------------------------
def query_bigquery_charts(request):
    """Queries BigQuery and returns data formatted for Google Charts."""
    # Handle CORS specifically for this endpoint
    if request.method == "OPTIONS":
        return handle_cors_options()
    headers = {"Access-Control-Allow-Origin": "*"}
    # 1. Parse Parameters
    request_json = request.get_json(silent=True)
    request_args = request.args
    code_param = request_args.get("code") or (request_json and request_json.get("code"))
    topic_param = request_args.get("topic") or (
        request_json and request_json.get("topic")
    )
    theme_param = request_args.get("theme") or (
        request_json and request_json.get("theme")
    )
    state_param = request_args.get("state") or (
        request_json and request_json.get("state")
    )
    find_param = request_args.get("find") or (request_json and request_json.get("find"))
    from_param = request_args.get("from") or (request_json and request_json.get("from"))
    to_param = request_args.get("to") or (request_json and request_json.get("to"))
    # Check for special modes
    dd_mode = "dd" in request_args
    un_mode = "un" in request_args
    # --- Mode: Unique Topics Only ---
    if un_mode:
        try:
            # Fetch unique topics
            topics_query = "SELECT DISTINCT topic FROM `obedio.meetings.meeting_details` WHERE topic IS NOT NULL ORDER BY topic"
            topics_job = get_bq_client().query(topics_query)
            topics = [row[0] for row in topics_job.result()]
            return json.dumps(topics), 200, headers
        except Exception as e:
            return json.dumps({"error": str(e)}), 500, headers
    # 2. Build SQL
    sql = "SELECT * FROM `obedio.meetings.meeting_details` AS t"
    where_clauses = []
    query_params = []
    if find_param:
        where_clauses.append("CONTAINS_SUBSTR(t, @find)")
        query_params.append(bigquery.ScalarQueryParameter("find", "STRING", find_param))
    if code_param:
        processed_codes = []
        # Split by comma and process each code
        for raw_code in code_param.split(","):
            c = raw_code.strip()
            if not c:
                continue
            # Check if code starts with M or S
            if c[0].upper() in ("M", "S"):
                processed_codes.append(c)
            else:
                # Assume M, and pad the numeric part to 8 digits
                # E.g. "123" -> "M00000123"
                processed_codes.append(f"M{c.zfill(8)}")
        if processed_codes:
            where_clauses.append("jcode IN UNNEST(@codes)")
            query_params.append(
                bigquery.ArrayQueryParameter("codes", "STRING", processed_codes)
            )
    if topic_param:
        where_clauses.append("LOWER(topic) LIKE @topic")
        query_params.append(
            bigquery.ScalarQueryParameter("topic", "STRING", f"%{topic_param.lower()}%")
        )
    if theme_param:
        where_clauses.append("LOWER(theme) LIKE @theme")
        query_params.append(
            bigquery.ScalarQueryParameter("theme", "STRING", f"%{theme_param.lower()}%")
        )
    if state_param and state_param.lower() != "all":
        # Clean up input: "ca, ny " -> ["CA", "NY"]
        states = [s.strip().upper() for s in state_param.split(",")]
        if states:
            where_clauses.append("state IN UNNEST(@states)")
            query_params.append(
                bigquery.ArrayQueryParameter("states", "STRING", states)
            )
    if from_param:
        where_clauses.append("date >= @from_date")
        query_params.append(
            bigquery.ScalarQueryParameter("from_date", "DATE", from_param)
        )
    if to_param:
        where_clauses.append("date <= @to_date")
        query_params.append(bigquery.ScalarQueryParameter("to_date", "DATE", to_param))
    if where_clauses:
        sql += " WHERE " + " AND ".join(where_clauses)
    # Sort by date descending
    sql += " ORDER BY date DESC"
    # --- Mode: Data Definition (Schema Only) ---
    if dd_mode:
        sql += " LIMIT 0"
    else:
        sql += " LIMIT 5000"
    # 3. Execute
    try:
        job_config = bigquery.QueryJobConfig(
            query_parameters=query_params, use_legacy_sql=False
        )
        query_job = get_bq_client().query(sql, job_config=job_config)
        rows = query_job.result()  # Waits for completion
        # 4. Format Output
        schema = rows.schema
        cols = [
            {
                "id": field.name,
                "label": field.name,
                "type": map_bq_type_to_charts(field.field_type),
            }
            for field in schema
        ]
        chart_rows = []
        for row in rows:
            cells = []
            for field in schema:
                val = row[field.name]
                formatted_val = format_value_for_charts(val, field.field_type)
                cells.append({"v": formatted_val})
            chart_rows.append({"c": cells})
        data_table = {"cols": cols, "rows": chart_rows}
        return json.dumps(data_table), 200, headers
    except Exception as e:
        print(f"BQ Error: {e}")
        return json.dumps({"error": str(e)}), 500, headers
# ---------------------------------------------------------
# ROUTE: /j (JSON Data Export)
# ---------------------------------------------------------
def query_bigquery_json(request):
    """Returns matching rows as a standard JSON array of objects."""
    if request.method == "OPTIONS":
        return handle_cors_options()
    headers = {"Access-Control-Allow-Origin": "*", "Content-Type": "application/json"}
    # 1. Parse parameters
    state_param = request.args.get("state")
    jtype_param = request.args.get("jtype")
    # 2. Build SQL
    sql = "SELECT * FROM `obedio.meetings.jurisdictions`"
    query_params = []
    where_clauses = []
    # Filter by State
    if state_param and state_param.lower() != "all":
        # Clean up input: "ca, ny " -> ["CA", "NY"]
        states = [s.strip().upper() for s in state_param.split(",")]
        if states:
            where_clauses.append("state IN UNNEST(@states)")
            query_params.append(
                bigquery.ArrayQueryParameter("states", "STRING", states)
            )
    # Filter by Type (M or S)
    if jtype_param:
        jtype_val = jtype_param.strip().upper()
        if jtype_val in ("M", "S"):
            where_clauses.append("jtype = @jtype")
            query_params.append(
                bigquery.ScalarQueryParameter("jtype", "STRING", jtype_val)
            )
    if where_clauses:
        sql += " WHERE " + " AND ".join(where_clauses)
    # 3. Execute
    try:
        job_config = bigquery.QueryJobConfig(query_parameters=query_params)
        query_job = get_bq_client().query(sql, job_config=job_config)
        rows = query_job.result()
        # 4. Convert to list of dicts (BigQuery rows are Row objects)
        # We use a custom encoder or manual conversion for Date/Decimal types
        results = []
        for row in rows:
            dict_row = dict(row.items())
            # Convert non-serializable types to strings/floats
            for key, value in dict_row.items():
                if isinstance(value, (datetime.date, datetime.datetime)):
                    dict_row[key] = value.isoformat()
                elif isinstance(value, decimal.Decimal):
                    dict_row[key] = float(value)
            results.append(dict_row)
        return json.dumps(results), 200, headers
    except Exception as e:
        print(f"JSON Route Error: {e}")
        return json.dumps({"error": str(e)}), 500, headers
# ---------------------------------------------------------
# Helpers
# ---------------------------------------------------------
def handle_cors_options():
    headers = {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST",
        "Access-Control-Allow-Headers": "Content-Type",
        "Access-Control-Max-Age": "3600",
    }
    return "", 204, headers
def map_bq_type_to_charts(bq_type):
    t = bq_type.upper()
    if t in ("INTEGER", "INT64", "FLOAT", "FLOAT64", "NUMERIC", "BIGNUMERIC"):
        return "number"
    elif t in ("BOOLEAN", "BOOL"):
        return "boolean"
    elif t == "DATE":
        return "date"
    elif t in ("DATETIME", "TIMESTAMP"):
        return "datetime"
    return "string"
def format_value_for_charts(val, bq_type):
    if val is None:
        return None
    t = bq_type.upper()
    if t == "DATE":
        # val is datetime.date. Month is 0-indexed in JS.
        return f"Date({val.year}, {val.month - 1}, {val.day})"
    elif t in ("DATETIME", "TIMESTAMP"):
        # val is datetime.datetime
        return f"Date({val.year}, {val.month - 1}, {val.day}, {val.hour}, {val.minute}, {val.second})"
    elif t in ("NUMERIC", "BIGNUMERIC"):
        return float(val)
    return val
